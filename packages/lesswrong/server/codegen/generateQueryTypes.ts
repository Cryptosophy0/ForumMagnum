import { allQueries } from '../../lib/queries';
import { generatedFileHeader, parsedGraphqlTypeToTypescript, assert } from './typeGenerationUtils';
import { getAdditionalSchemas } from '../../lib/vulcan-lib/graphql';
import { getFragmentFieldType } from './generateFragmentTypes';
import gql from 'graphql-tag';
import { visit as gqlVisit } from 'graphql';

const queryFileHeader = generatedFileHeader+`//
// Contains Typescript signatures for queries, generated by
// server/codegen/generateQueryTypes.ts.
//
`

export function generateQueryTypes(context: TypeGenerationContext): string {
  const sb: string[] = [];
  const queryNames = Object.keys(allQueries);
  
  for (const queryName of queryNames) {
    const queryGraphqlStr = allQueries[queryName];
    const parsedGraphql = gql(queryGraphqlStr);
    assert(parsedGraphql.definitions.length===1);
    const queryParsedGraphql = parsedGraphql.definitions[0];
    assert(queryParsedGraphql.kind==="OperationDefinition");
    
    const resultType = generateQueryTypeDefinition({context, queryName, parsedQuery: queryParsedGraphql});
    sb.push(resultType);
    const argumentsType = generateQueryArgumentsTypeDefinition(context, queryName, queryParsedGraphql);
    sb.push(argumentsType);
  }
  
  sb.push("interface QueryResultTypes {\n");
  for (const queryName of queryNames) {
    sb.push(`  ${queryName}: Query${queryName}Result\n`);
  }
  sb.push("}\n\n");
  
  sb.push("interface QueryArgumentTypes {\n");
  for (const queryName of queryNames) {
    sb.push(`  readonly ${queryName}: Query${queryName}Variables\n`);
  }
  sb.push("}\n\n");
  
  sb.push(`type QueryName = ${queryNames.map(n=>JSON.stringify(n)).join("|")}\n`);
  
  return queryFileHeader + sb.join('');
}

const extractQueryName = (queryText: string): string => {
  const match = queryText.match(/query ([_a-zA-Z][_a-zA-Z0-9]+)/)
  if (!match) throw new Error("Could not extract query name");
  return match[1];
}

export function generateQueryArgumentsTypeDefinition(context: TypeGenerationContext, queryName: string, parsedGraphqlVariables: any) {
  const sb: string[] = [];
  
  sb.push(`interface Query${queryName}Variables {\n`);
  for (let variableDefinition of parsedGraphqlVariables.variableDefinitions) {
    const parsedGraphqlType = variableDefinition.type;
    const variableName = variableDefinition?.variable?.name?.value;
    sb.push(`  ${variableName}: ${parsedGraphqlTypeToTypescript(parsedGraphqlType)}\n`);
  }
  sb.push(`}\n\n`);
  
  return sb.join('');
}

function generateQueryTypeDefinition({context, queryName, parsedQuery}: {
  context: TypeGenerationContext,
  queryName: string,
  parsedQuery: any
}): string {
  const sb: Array<string> = [];
  const interfaceName = `Query${queryName}Result`;
  const allSubfragments: Array<string> = [];
  
  sb.push(`interface ${interfaceName} {\n`);
  
  for (let selection of parsedQuery?.selectionSet?.selections) {
    switch(selection.kind) {
      case "Field":
        const { fieldType, subfragment } = getSelectionFieldType({
          context, selection,
          namePrefix: interfaceName+"_",
        });
        const selectionType = fieldType
        sb.push(`  readonly ${selection.name.value}: ${selectionType},\n`);
        if (subfragment)
          allSubfragments.push(subfragment);
        break;
      case "FragmentSpread":
        break; //TODO
      default:
        throw new Error("Unrecognized GraphQL selection kind: "+selection.kind);
    }
  }
  
  sb.push(`}\n\n`);
  for (let subfragment of allSubfragments)
    sb.push(subfragment);
  
  return sb.join('');
}

function getSelectionFieldType({context, selection, selectedFrom, namePrefix}: {
  context: TypeGenerationContext,
  selection: any,
  selectedFrom: any,
  namePrefix: string,
}): { fieldType: string, subfragment: string|null } {
  const fieldName = selection.name.value;
  
  if (selection.selectionSet) {
    const subfragmentName = namePrefix+fieldName;
    const subfragmentSb: string[] = [];
    subfragmentSb.push(`interface ${subfragmentName} {\n`);
    for (let subselection of selection.selectionSet.selections) {
      subfragmentSb.push(`  ${subselection.name.value}: any\n`); //TODO
    }
    subfragmentSb.push(`}\n`);
    return {
      fieldType: subfragmentName,
      subfragment: subfragmentSb.join(""),
    };
  } else {
    // TODO
    return {
      fieldType: "any",
      subfragment: null,
    };
  }
}

export function graphqlSchemasToTS(context: TypeGenerationContext): string {
  const sb: string[] = [];
  const parsedGqlSchemas = gql(getAdditionalSchemas());
  
  for (let declaration of parsedGqlSchemas.definitions) {
    if (declaration?.kind === "ObjectTypeDefinition") {
      sb.push(graphqlTypeDeclarationToTypescript(context, declaration));
    }
  }
  
  return sb.join('');
}

export function graphqlTypeDeclarationStrToTypescript(context: TypeGenerationContext, typeDeclaration: string) {
  const parsedGql = gql(typeDeclaration);
  const sb: string[] = [];
  
  for (let definition of parsedGql.definitions) {
    if (definition?.kind === "ObjectTypeDefinition" && definition.fields) {
      sb.push(graphqlTypeDeclarationToTypescript(context, definition));
    }
  }
  
  return sb.join('');
}

export function graphqlTypeDeclarationToTypescript(context: TypeGenerationContext, declaration: any) {
  const sb: string[] = [];
  const objectTypeName = declaration.name.value;
  sb.push(`interface ${objectTypeName} {\n`);
  for (let field of declaration.fields) {
    const fieldName = field.name?.value;
    const fieldTypeGql = field.type;
    const fieldTypeTS = parsedGraphqlTypeToTypescript(fieldTypeGql);
    sb.push(`  ${fieldName}: ${fieldTypeTS}\n`);
  }
  sb.push('}\n');
  
  return sb.join('');
}


