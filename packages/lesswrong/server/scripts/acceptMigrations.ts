/* eslint-disable no-console */
import { fs } from 'mz';
import path from 'path';

const ROOT_PATH = path.join(__dirname, "../../../");
const schemaChangelogPath = (rootPath: string) => path.join(rootPath, "schema/schema_changelog.json");
export const migrationsPath = (rootPath: string) => path.join(rootPath, "packages/lesswrong/server/migrations");

export interface SchemaChangelogEntry {
  acceptsSchemaHash: string
  acceptedByMigration?: string
  timestamp: string
}

const assertNoDuplicateTimestamps = (entries: SchemaChangelogEntry[]) => {
  const timestamps = entries.map(e => e.timestamp);
  const uniqueTimestamps = new Set(timestamps);
  if (timestamps.length !== uniqueTimestamps.size) {
    throw new Error(`Duplicate timestamps: ${timestamps.sort()}`);
  }
}

const getSchemaChangelogEntries = async (rootPath: string): Promise<SchemaChangelogEntry[]> => {
  const schemaChangelog = await fs.readFile(schemaChangelogPath(rootPath), 'utf8');
  return JSON.parse(schemaChangelog);
}

const getMigrationChangelogEntries = async (rootPath: string): Promise<SchemaChangelogEntry[]> => {
  const migrationFiles = (
    (await fs.readdir(migrationsPath(rootPath), { withFileTypes: true }))
      .filter(dirent => dirent.isFile())
      .map(dirent => path.join(migrationsPath(rootPath), dirent.name))
  );
  
  const migrationChangelogEntries: SchemaChangelogEntry[] = [];
  for (const migrationFile of migrationFiles) {
    const acceptsHashRegex = new RegExp(/^export const acceptsSchemaHash = "(.*)"/);
    // Use this regex hack rather than importing because esbuild doesn't support dynamic imports
    const contents = fs.readFileSync(migrationFile).toString().split("\n");
    const acceptsHashLine = contents.find(line => acceptsHashRegex.test(line));
    
    if (!acceptsHashLine) continue;

    const match = acceptsHashRegex.exec(acceptsHashLine);
    
    if (!match) throw new Error(`Invalid acceptsHashLine: ${acceptsHashLine}`);
    
    const acceptsHash = match[1];
    const migrationName = path.basename(migrationFile);
    const timestamp = migrationNameToTime(migrationName);
    
    migrationChangelogEntries.push({
      acceptsSchemaHash: acceptsHash,
      acceptedByMigration: migrationName,
      timestamp: timestamp.toISOString(),
    });
  }
  
  return migrationChangelogEntries;
}

const arrayToTimestampMap = (array: SchemaChangelogEntry[]): Record<string, SchemaChangelogEntry> => {
  const map: Record<string, SchemaChangelogEntry> = {};
  for (const entry of array) {
    map[entry.timestamp] = entry;
  }
  return map;
}

const updateSchemaChangelogWithMigrationEntries = async ({
  schemaChangelogEntries,
  migrationChangelogEntries}: {
  schemaChangelogEntries: SchemaChangelogEntry[],
  migrationChangelogEntries: SchemaChangelogEntry[]
}) => {
  assertNoDuplicateTimestamps(schemaChangelogEntries);
  assertNoDuplicateTimestamps(migrationChangelogEntries);

  const schemaChangelogEntriesMap = arrayToTimestampMap(schemaChangelogEntries);
  const migrationChangelogEntriesMap = arrayToTimestampMap(migrationChangelogEntries);
  
  const newSchemaChangelogEntries: SchemaChangelogEntry[] = [];
  
  for (const timestamp in migrationChangelogEntriesMap) {
    if (schemaChangelogEntriesMap[timestamp]) {
      const existingEntry = schemaChangelogEntriesMap[timestamp];
      const newEntry = migrationChangelogEntriesMap[timestamp];
      if (existingEntry.acceptsSchemaHash !== newEntry.acceptsSchemaHash ||
          existingEntry.acceptedByMigration !== newEntry.acceptedByMigration) {
          throw new Error(`Cannot change accepted migration: ${timestamp}. The entry in schema_changelog.json is ${existingEntry}`
            + ` but the entry generated by the migration file is ${newEntry}`);
      }
    } else {
      console.log("Adding new entry to schema_changelog.json:\n", migrationChangelogEntriesMap[timestamp]);
    }
    newSchemaChangelogEntries.push(migrationChangelogEntriesMap[timestamp]);
  }
  
  const manualEntries = schemaChangelogEntries.filter(entry => !migrationChangelogEntriesMap[entry.timestamp]);
  
  // Assert that the manual entries are in fact manual, if they have an acceptedByMigration field this
  // probably means that the migration file was deleted
  const invalidManualEntries = manualEntries.filter(entry => entry.acceptedByMigration)
  if (invalidManualEntries.length) {
    throw new Error(`There are entries with an acceptedByMigration field in schema_changelog.json where the corresponding migration can't be found: ${invalidManualEntries}`);
  }
  
  newSchemaChangelogEntries.push(...manualEntries);
  return newSchemaChangelogEntries.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
}

export const acceptMigrations = async ({write=true, rootPath=ROOT_PATH}: {write: boolean, rootPath: string}): Promise<SchemaChangelogEntry> => {
  // TODO rename to make clearer
  const schemaChangelogEntries = await getSchemaChangelogEntries(rootPath);
  const migrationChangelogEntries = await getMigrationChangelogEntries(rootPath);
  
  /**
   * There are two ways you can "accept" a schema change, by adding a migration file with export const acceptsSchemaHash = "...",
   * or by manually editing schema_changelog.json. We now want to merge the two, so that the schema_changelog.json file
   * has the most up to date information about which schema hashes are accepted. In doing this, we want to:
   * - preserve manually added entries in schema_changelog.json (i.e. entries without acceptedByMigration)
   * - allow people to rename migration files before the change is accepted
   * - allow people to delete migration files before the change is accepted (e.g. if you add an extra field and want to regenerate the migration file)
   * - assert that all the ACCEPTED migration files still exist
   */
  const newSchemaChangelogEntries = await updateSchemaChangelogWithMigrationEntries({schemaChangelogEntries, migrationChangelogEntries});
   
  if (write) {
    await fs.writeFile(schemaChangelogPath(rootPath), JSON.stringify(newSchemaChangelogEntries, null, 2));
  } else {
    if (JSON.stringify(newSchemaChangelogEntries) !== JSON.stringify(schemaChangelogEntries)) {
      throw new Error(`schema_changelog.json is out of date. Run 'yarn checkschema' to update it.`);
    }
  }

  return newSchemaChangelogEntries[newSchemaChangelogEntries.length - 1];
}

// TODO use Ollie's version of this, NOTE CHANGING FROM TIME TO DATE
const migrationNameToTime = (name: string): Date => {
  const s = name.split(".")[0];
  if (s.length !== 15 || s[8] !== "T") {
    throw new Error(`Invalid migration name: '${s}'`);
  }
  const stamp = `${s.slice(0, 4)}-${s.slice(4, 6)}-${s.slice(6, 11)}:${s.slice(11, 13)}:${s.slice(13, 15)}.000Z`;
  return new Date(stamp);
}
